//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IApiClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginCommand | undefined): Observable<AuthenticationResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: RegisterCommand | undefined): Observable<AuthenticationResponse>;
    /**
     * @return OK
     */
    boardsAll(): Observable<GetAllBoardsDto[]>;
    /**
     * @param body (optional) 
     * @return Created
     */
    boardsPOST(body: CreateBoardCommand | undefined): Observable<string>;
    /**
     * @return OK
     */
    boardsGET(id: string): Observable<GetBoardByIdDto>;
    /**
     * @return No Content
     */
    boardsDELETE(id: string): Observable<void>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    boardsPUT(id: string, body: UpdateBoardCommand | undefined): Observable<void>;
    /**
     * @return OK
     */
    thread(threadId: string): Observable<GetPostByThreadIdDto[]>;
    /**
     * @return OK
     */
    postsGET(id: string): Observable<GetPostByIdDto>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    postsPUT(id: string, body: UpdatePostCommand | undefined): Observable<void>;
    /**
     * @return No Content
     */
    postsDELETE(id: string): Observable<void>;
    /**
     * @param body (optional) 
     * @return Created
     */
    postsPOST(body: CreatePostCommand | undefined): Observable<void>;
    /**
     * @return OK
     */
    threadsGET(id: string): Observable<GetThreadByIdDto>;
    /**
     * @return No Content
     */
    threadsDELETE(id: string): Observable<void>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    threadsPUT(id: string, body: UpdateThreadCommand | undefined): Observable<void>;
    /**
     * @return OK
     */
    board(boardId: string): Observable<GetThreadsByBoardIdDto[]>;
    /**
     * @return No Content
     */
    close(id: string): Observable<void>;
    /**
     * @param body (optional) 
     * @return Created
     */
    threadsPOST(body: CreateThreadCommand | undefined): Observable<void>;
    /**
     * @return No Content
     */
    open(id: string): Observable<void>;
    /**
     * @return No Content
     */
    stick(id: string): Observable<void>;
    /**
     * @return No Content
     */
    unstick(id: string): Observable<void>;
    /**
     * @return OK
     */
    usersAll(): Observable<GetAllUsersDto[]>;
    /**
     * @return OK
     */
    usersGET(id: string): Observable<GetUserByIdDto>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    usersPUT(id: string, body: UpdateUserCommand | undefined): Observable<void>;
    /**
     * @return No Content
     */
    usersDELETE(id: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class ApiClient implements IApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginCommand | undefined): Observable<AuthenticationResponse> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: RegisterCommand | undefined): Observable<AuthenticationResponse> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<AuthenticationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    boardsAll(): Observable<GetAllBoardsDto[]> {
        let url_ = this.baseUrl + "/api/boards";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBoardsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBoardsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllBoardsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllBoardsDto[]>;
        }));
    }

    protected processBoardsAll(response: HttpResponseBase): Observable<GetAllBoardsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllBoardsDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    boardsPOST(body: CreateBoardCommand | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/boards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBoardsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBoardsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processBoardsPOST(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : null as any;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    boardsGET(id: string): Observable<GetBoardByIdDto> {
        let url_ = this.baseUrl + "/api/boards/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBoardsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBoardsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBoardByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBoardByIdDto>;
        }));
    }

    protected processBoardsGET(response: HttpResponseBase): Observable<GetBoardByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBoardByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    boardsDELETE(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/boards/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBoardsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBoardsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBoardsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    boardsPUT(id: string, body: UpdateBoardCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/boards/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBoardsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBoardsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBoardsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    thread(threadId: string): Observable<GetPostByThreadIdDto[]> {
        let url_ = this.baseUrl + "/api/posts/thread/{threadId}";
        if (threadId === undefined || threadId === null)
            throw new globalThis.Error("The parameter 'threadId' must be defined.");
        url_ = url_.replace("{threadId}", encodeURIComponent("" + threadId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThread(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPostByThreadIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPostByThreadIdDto[]>;
        }));
    }

    protected processThread(response: HttpResponseBase): Observable<GetPostByThreadIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPostByThreadIdDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    postsGET(id: string): Observable<GetPostByIdDto> {
        let url_ = this.baseUrl + "/api/posts/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPostByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPostByIdDto>;
        }));
    }

    protected processPostsGET(response: HttpResponseBase): Observable<GetPostByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPostByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    postsPUT(id: string, body: UpdatePostCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/posts/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = CustomProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    postsDELETE(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/posts/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    postsPOST(body: CreatePostCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/posts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostsPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = CustomProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    threadsGET(id: string): Observable<GetThreadByIdDto> {
        let url_ = this.baseUrl + "/api/threads/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThreadsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThreadsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetThreadByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetThreadByIdDto>;
        }));
    }

    protected processThreadsGET(response: HttpResponseBase): Observable<GetThreadByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetThreadByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    threadsDELETE(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/threads/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThreadsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThreadsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processThreadsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    threadsPUT(id: string, body: UpdateThreadCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/threads/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThreadsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThreadsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processThreadsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = CustomProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    board(boardId: string): Observable<GetThreadsByBoardIdDto[]> {
        let url_ = this.baseUrl + "/api/threads/board/{boardId}";
        if (boardId === undefined || boardId === null)
            throw new globalThis.Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBoard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBoard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetThreadsByBoardIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetThreadsByBoardIdDto[]>;
        }));
    }

    protected processBoard(response: HttpResponseBase): Observable<GetThreadsByBoardIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetThreadsByBoardIdDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    close(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/threads/close/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClose(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClose(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClose(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    threadsPOST(body: CreateThreadCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/threads";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThreadsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThreadsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processThreadsPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = CustomProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    open(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/threads/open/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOpen(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    stick(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/threads/stick/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStick(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStick(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStick(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    unstick(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/threads/unstick/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnstick(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnstick(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnstick(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    usersAll(): Observable<GetAllUsersDto[]> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllUsersDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllUsersDto[]>;
        }));
    }

    protected processUsersAll(response: HttpResponseBase): Observable<GetAllUsersDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllUsersDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    usersGET(id: string): Observable<GetUserByIdDto> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserByIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserByIdDto>;
        }));
    }

    protected processUsersGET(response: HttpResponseBase): Observable<GetUserByIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserByIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    usersPUT(id: string, body: UpdateUserCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUsersPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = CustomProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    usersDELETE(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUsersDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CustomProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AuthenticationResponse implements IAuthenticationResponse {
    token?: string | undefined;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IAuthenticationResponse {
    token?: string | undefined;
}

export class CreateBoardCommand implements ICreateBoardCommand {
    parentBoardId?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    sortOrder?: number;

    constructor(data?: ICreateBoardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentBoardId = _data["parentBoardId"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateBoardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBoardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentBoardId"] = this.parentBoardId;
        data["description"] = this.description;
        data["title"] = this.title;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface ICreateBoardCommand {
    parentBoardId?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    sortOrder?: number;
}

export class CreatePostCommand implements ICreatePostCommand {
    threadId?: string;
    parentPostId?: string | undefined;
    content?: string | undefined;

    constructor(data?: ICreatePostCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.threadId = _data["threadId"];
            this.parentPostId = _data["parentPostId"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): CreatePostCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePostCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["parentPostId"] = this.parentPostId;
        data["content"] = this.content;
        return data;
    }
}

export interface ICreatePostCommand {
    threadId?: string;
    parentPostId?: string | undefined;
    content?: string | undefined;
}

export class CreateThreadCommand implements ICreateThreadCommand {
    boardId?: string;
    title?: string | undefined;

    constructor(data?: ICreateThreadCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.boardId = _data["boardId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateThreadCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateThreadCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boardId"] = this.boardId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateThreadCommand {
    boardId?: string;
    title?: string | undefined;
}

export class CustomProblemDetails implements ICustomProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: ICustomProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (this.errors as any)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): CustomProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CustomProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (data["errors"] as any)[key] = (this.errors as any)[key];
            }
        }
        return data;
    }
}

export interface ICustomProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

export class GetAllBoardsDto implements IGetAllBoardsDto {
    created?: Date;
    updated?: Date | undefined;
    id?: string;
    parentBoardId?: string | undefined;
    sortOrder?: number;
    subBoardCount?: number;
    threadCount?: number;
    description?: string | undefined;
    title?: string | undefined;

    constructor(data?: IGetAllBoardsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : undefined as any;
            this.id = _data["id"];
            this.parentBoardId = _data["parentBoardId"];
            this.sortOrder = _data["sortOrder"];
            this.subBoardCount = _data["subBoardCount"];
            this.threadCount = _data["threadCount"];
            this.description = _data["description"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): GetAllBoardsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllBoardsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        data["updated"] = this.updated ? this.updated.toISOString() : undefined as any;
        data["id"] = this.id;
        data["parentBoardId"] = this.parentBoardId;
        data["sortOrder"] = this.sortOrder;
        data["subBoardCount"] = this.subBoardCount;
        data["threadCount"] = this.threadCount;
        data["description"] = this.description;
        data["title"] = this.title;
        return data;
    }
}

export interface IGetAllBoardsDto {
    created?: Date;
    updated?: Date | undefined;
    id?: string;
    parentBoardId?: string | undefined;
    sortOrder?: number;
    subBoardCount?: number;
    threadCount?: number;
    description?: string | undefined;
    title?: string | undefined;
}

export class GetAllUsersDto implements IGetAllUsersDto {
    created?: Date;
    updated?: Date | undefined;
    id?: string;
    displayName?: string | undefined;
    email?: string | undefined;

    constructor(data?: IGetAllUsersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : undefined as any;
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): GetAllUsersDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUsersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        data["updated"] = this.updated ? this.updated.toISOString() : undefined as any;
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        return data;
    }
}

export interface IGetAllUsersDto {
    created?: Date;
    updated?: Date | undefined;
    id?: string;
    displayName?: string | undefined;
    email?: string | undefined;
}

export class GetBoardByIdBoardListItemDto implements IGetBoardByIdBoardListItemDto {
    id?: string;
    threadCount?: number;
    title?: string | undefined;

    constructor(data?: IGetBoardByIdBoardListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.threadCount = _data["threadCount"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): GetBoardByIdBoardListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBoardByIdBoardListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["threadCount"] = this.threadCount;
        data["title"] = this.title;
        return data;
    }
}

export interface IGetBoardByIdBoardListItemDto {
    id?: string;
    threadCount?: number;
    title?: string | undefined;
}

export class GetBoardByIdDto implements IGetBoardByIdDto {
    createdByUserId?: string;
    id?: string;
    parentBoardId?: string | undefined;
    postCount?: number;
    threadCount?: number;
    sortOrder?: number;
    subBoards?: GetBoardByIdBoardListItemDto[] | undefined;
    threads?: GetBoardByIdThreadListItemDto[] | undefined;
    moderators?: GetBoardByIdUserDto[] | undefined;
    createdByUsername?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    parentBoardTitle?: string | undefined;

    constructor(data?: IGetBoardByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdByUserId = _data["createdByUserId"];
            this.id = _data["id"];
            this.parentBoardId = _data["parentBoardId"];
            this.postCount = _data["postCount"];
            this.threadCount = _data["threadCount"];
            this.sortOrder = _data["sortOrder"];
            if (Array.isArray(_data["subBoards"])) {
                this.subBoards = [] as any;
                for (let item of _data["subBoards"])
                    this.subBoards!.push(GetBoardByIdBoardListItemDto.fromJS(item));
            }
            if (Array.isArray(_data["threads"])) {
                this.threads = [] as any;
                for (let item of _data["threads"])
                    this.threads!.push(GetBoardByIdThreadListItemDto.fromJS(item));
            }
            if (Array.isArray(_data["moderators"])) {
                this.moderators = [] as any;
                for (let item of _data["moderators"])
                    this.moderators!.push(GetBoardByIdUserDto.fromJS(item));
            }
            this.createdByUsername = _data["createdByUsername"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.parentBoardTitle = _data["parentBoardTitle"];
        }
    }

    static fromJS(data: any): GetBoardByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBoardByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdByUserId"] = this.createdByUserId;
        data["id"] = this.id;
        data["parentBoardId"] = this.parentBoardId;
        data["postCount"] = this.postCount;
        data["threadCount"] = this.threadCount;
        data["sortOrder"] = this.sortOrder;
        if (Array.isArray(this.subBoards)) {
            data["subBoards"] = [];
            for (let item of this.subBoards)
                data["subBoards"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.threads)) {
            data["threads"] = [];
            for (let item of this.threads)
                data["threads"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.moderators)) {
            data["moderators"] = [];
            for (let item of this.moderators)
                data["moderators"].push(item ? item.toJSON() : undefined as any);
        }
        data["createdByUsername"] = this.createdByUsername;
        data["description"] = this.description;
        data["title"] = this.title;
        data["parentBoardTitle"] = this.parentBoardTitle;
        return data;
    }
}

export interface IGetBoardByIdDto {
    createdByUserId?: string;
    id?: string;
    parentBoardId?: string | undefined;
    postCount?: number;
    threadCount?: number;
    sortOrder?: number;
    subBoards?: GetBoardByIdBoardListItemDto[] | undefined;
    threads?: GetBoardByIdThreadListItemDto[] | undefined;
    moderators?: GetBoardByIdUserDto[] | undefined;
    createdByUsername?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    parentBoardTitle?: string | undefined;
}

export class GetBoardByIdThreadListItemDto implements IGetBoardByIdThreadListItemDto {
    created?: Date;
    updated?: Date | undefined;
    createdByUserId?: string;
    id?: string;
    postCount?: number;
    createdByUsername?: string | undefined;
    title?: string | undefined;

    constructor(data?: IGetBoardByIdThreadListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.id = _data["id"];
            this.postCount = _data["postCount"];
            this.createdByUsername = _data["createdByUsername"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): GetBoardByIdThreadListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBoardByIdThreadListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        data["updated"] = this.updated ? this.updated.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["id"] = this.id;
        data["postCount"] = this.postCount;
        data["createdByUsername"] = this.createdByUsername;
        data["title"] = this.title;
        return data;
    }
}

export interface IGetBoardByIdThreadListItemDto {
    created?: Date;
    updated?: Date | undefined;
    createdByUserId?: string;
    id?: string;
    postCount?: number;
    createdByUsername?: string | undefined;
    title?: string | undefined;
}

export class GetBoardByIdUserDto implements IGetBoardByIdUserDto {
    id?: string;
    displayName?: string | undefined;

    constructor(data?: IGetBoardByIdUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): GetBoardByIdUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBoardByIdUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IGetBoardByIdUserDto {
    id?: string;
    displayName?: string | undefined;
}

export class GetPostByIdDto implements IGetPostByIdDto {
    created?: Date;
    updated?: Date | undefined;
    createdByUserId?: string;
    id?: string;
    threadId?: string;
    parentPostId?: string | undefined;
    content?: string | undefined;
    createdByUsername?: string | undefined;
    threadTitle?: string | undefined;
    parentPostPreview?: string | undefined;

    constructor(data?: IGetPostByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.id = _data["id"];
            this.threadId = _data["threadId"];
            this.parentPostId = _data["parentPostId"];
            this.content = _data["content"];
            this.createdByUsername = _data["createdByUsername"];
            this.threadTitle = _data["threadTitle"];
            this.parentPostPreview = _data["parentPostPreview"];
        }
    }

    static fromJS(data: any): GetPostByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPostByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        data["updated"] = this.updated ? this.updated.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["id"] = this.id;
        data["threadId"] = this.threadId;
        data["parentPostId"] = this.parentPostId;
        data["content"] = this.content;
        data["createdByUsername"] = this.createdByUsername;
        data["threadTitle"] = this.threadTitle;
        data["parentPostPreview"] = this.parentPostPreview;
        return data;
    }
}

export interface IGetPostByIdDto {
    created?: Date;
    updated?: Date | undefined;
    createdByUserId?: string;
    id?: string;
    threadId?: string;
    parentPostId?: string | undefined;
    content?: string | undefined;
    createdByUsername?: string | undefined;
    threadTitle?: string | undefined;
    parentPostPreview?: string | undefined;
}

export class GetPostByThreadIdDto implements IGetPostByThreadIdDto {
    created?: Date;
    updated?: Date | undefined;
    createdByUserId?: string;
    id?: string;
    threadId?: string;
    parentPostId?: string | undefined;
    content?: string | undefined;
    createdByUsername?: string | undefined;

    constructor(data?: IGetPostByThreadIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.id = _data["id"];
            this.threadId = _data["threadId"];
            this.parentPostId = _data["parentPostId"];
            this.content = _data["content"];
            this.createdByUsername = _data["createdByUsername"];
        }
    }

    static fromJS(data: any): GetPostByThreadIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPostByThreadIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        data["updated"] = this.updated ? this.updated.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["id"] = this.id;
        data["threadId"] = this.threadId;
        data["parentPostId"] = this.parentPostId;
        data["content"] = this.content;
        data["createdByUsername"] = this.createdByUsername;
        return data;
    }
}

export interface IGetPostByThreadIdDto {
    created?: Date;
    updated?: Date | undefined;
    createdByUserId?: string;
    id?: string;
    threadId?: string;
    parentPostId?: string | undefined;
    content?: string | undefined;
    createdByUsername?: string | undefined;
}

export class GetThreadByIdDto implements IGetThreadByIdDto {
    isClosed?: boolean;
    isSticky?: boolean;
    created?: Date;
    updated?: Date | undefined;
    boardId?: string;
    createdByUserId?: string;
    id?: string;
    posts?: GetThreadByIdPostListItemDto[] | undefined;
    boardTitle?: string | undefined;
    createdByUsername?: string | undefined;
    title?: string | undefined;

    constructor(data?: IGetThreadByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isClosed = _data["isClosed"];
            this.isSticky = _data["isSticky"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : undefined as any;
            this.boardId = _data["boardId"];
            this.createdByUserId = _data["createdByUserId"];
            this.id = _data["id"];
            if (Array.isArray(_data["posts"])) {
                this.posts = [] as any;
                for (let item of _data["posts"])
                    this.posts!.push(GetThreadByIdPostListItemDto.fromJS(item));
            }
            this.boardTitle = _data["boardTitle"];
            this.createdByUsername = _data["createdByUsername"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): GetThreadByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetThreadByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isClosed"] = this.isClosed;
        data["isSticky"] = this.isSticky;
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        data["updated"] = this.updated ? this.updated.toISOString() : undefined as any;
        data["boardId"] = this.boardId;
        data["createdByUserId"] = this.createdByUserId;
        data["id"] = this.id;
        if (Array.isArray(this.posts)) {
            data["posts"] = [];
            for (let item of this.posts)
                data["posts"].push(item ? item.toJSON() : undefined as any);
        }
        data["boardTitle"] = this.boardTitle;
        data["createdByUsername"] = this.createdByUsername;
        data["title"] = this.title;
        return data;
    }
}

export interface IGetThreadByIdDto {
    isClosed?: boolean;
    isSticky?: boolean;
    created?: Date;
    updated?: Date | undefined;
    boardId?: string;
    createdByUserId?: string;
    id?: string;
    posts?: GetThreadByIdPostListItemDto[] | undefined;
    boardTitle?: string | undefined;
    createdByUsername?: string | undefined;
    title?: string | undefined;
}

export class GetThreadByIdPostListItemDto implements IGetThreadByIdPostListItemDto {
    created?: Date;
    updated?: Date | undefined;
    createdByUserId?: string;
    id?: string;
    content?: string | undefined;
    createdByUsername?: string | undefined;

    constructor(data?: IGetThreadByIdPostListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.id = _data["id"];
            this.content = _data["content"];
            this.createdByUsername = _data["createdByUsername"];
        }
    }

    static fromJS(data: any): GetThreadByIdPostListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetThreadByIdPostListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        data["updated"] = this.updated ? this.updated.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["id"] = this.id;
        data["content"] = this.content;
        data["createdByUsername"] = this.createdByUsername;
        return data;
    }
}

export interface IGetThreadByIdPostListItemDto {
    created?: Date;
    updated?: Date | undefined;
    createdByUserId?: string;
    id?: string;
    content?: string | undefined;
    createdByUsername?: string | undefined;
}

export class GetThreadsByBoardIdDto implements IGetThreadsByBoardIdDto {
    isClosed?: boolean;
    isSticky?: boolean;
    created?: Date;
    updated?: Date | undefined;
    createdByUserId?: string;
    id?: string;
    postCount?: number;
    createdByUsername?: string | undefined;
    title?: string | undefined;

    constructor(data?: IGetThreadsByBoardIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isClosed = _data["isClosed"];
            this.isSticky = _data["isSticky"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.id = _data["id"];
            this.postCount = _data["postCount"];
            this.createdByUsername = _data["createdByUsername"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): GetThreadsByBoardIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetThreadsByBoardIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isClosed"] = this.isClosed;
        data["isSticky"] = this.isSticky;
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        data["updated"] = this.updated ? this.updated.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["id"] = this.id;
        data["postCount"] = this.postCount;
        data["createdByUsername"] = this.createdByUsername;
        data["title"] = this.title;
        return data;
    }
}

export interface IGetThreadsByBoardIdDto {
    isClosed?: boolean;
    isSticky?: boolean;
    created?: Date;
    updated?: Date | undefined;
    createdByUserId?: string;
    id?: string;
    postCount?: number;
    createdByUsername?: string | undefined;
    title?: string | undefined;
}

export class GetUserByIdDto implements IGetUserByIdDto {
    created?: Date;
    updated?: Date | undefined;
    id?: string;
    displayName?: string | undefined;
    email?: string | undefined;

    constructor(data?: IGetUserByIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : undefined as any;
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): GetUserByIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserByIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        data["updated"] = this.updated ? this.updated.toISOString() : undefined as any;
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        return data;
    }
}

export interface IGetUserByIdDto {
    created?: Date;
    updated?: Date | undefined;
    id?: string;
    displayName?: string | undefined;
    email?: string | undefined;
}

export class LoginCommand implements ILoginCommand {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginCommand {
    email?: string | undefined;
    password?: string | undefined;
}

export class RegisterCommand implements IRegisterCommand {
    email?: string | undefined;
    password?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): RegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IRegisterCommand {
    email?: string | undefined;
    password?: string | undefined;
    displayName?: string | undefined;
}

export class UpdateBoardCommand implements IUpdateBoardCommand {
    description?: string | undefined;
    title?: string | undefined;
    sortOrder?: number;

    constructor(data?: IUpdateBoardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.title = _data["title"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateBoardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBoardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["title"] = this.title;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IUpdateBoardCommand {
    description?: string | undefined;
    title?: string | undefined;
    sortOrder?: number;
}

export class UpdatePostCommand implements IUpdatePostCommand {
    content?: string | undefined;

    constructor(data?: IUpdatePostCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): UpdatePostCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePostCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data;
    }
}

export interface IUpdatePostCommand {
    content?: string | undefined;
}

export class UpdateThreadCommand implements IUpdateThreadCommand {
    title?: string | undefined;

    constructor(data?: IUpdateThreadCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateThreadCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateThreadCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface IUpdateThreadCommand {
    title?: string | undefined;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    displayName?: string | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IUpdateUserCommand {
    displayName?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}